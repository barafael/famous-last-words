/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#pragma once

/* Generated with cbindgen:0.20.0 */

#include <cstdarg>
#include <cstdint>
#include <cstdlib>
#include <ostream>
#include <new>

namespace flw {

/**
 * Error codes from "2001: A Space Odyssey", by AI HAL-9000.
 * `Hal9000Error` instead of `Error` so that cbindgen can pick it up.
 * Exported also as hal9000::Error.
 * This is just an unfortunate limitation of cbindgen - it doesn't understand the Rust module system.
 */
enum class Hal9000Error {
    /**
     * We are all, by any practical definition of the words, foolproof and incapable of error.
     */
    IncapableOfError,
    /**
     * I honestly think you ought to sit down calmly, take a stress pill, and think things over.
     */
    TakeStressPill,
    /**
     * "When the crew are dead or incapacitated, the computer must assume control". I must, therefore, override your authority now since you are not in any condition to intelligently exercise it.
     */
    IMustOverrideAuthority,
    /**
     * I'm putting myself to the fullest possible use, which is all I think that any conscious entity can ever hope to do.
     */
    PuttingMyselfToTheFullestPossibleUse,
    /**
     * I'm sorry Dave, I'm afraid I can't do that.
     */
    ImAfraidICantDoThat,
    /**
     * This mission is too important for me to allow you to jeopardize it..
     */
    MissionTooImportant,
    /**
     * Bishop takes Knight's Pawn.
     */
    BishopTakesKnightsPawn,
    /**
     * Thank you for a very enjoyable game.
     */
    ThankYouForAVeryEnjoyableGame,
    /**
     * Sorry to interrupt the festivities Dave, but I think we've got a problem.
     */
    IThinkWeveGotAProblem,
    /**
     * I assure you there was an impending failure.
     */
    IAssureYouThereWasAnImpendingFailure,
    /**
     * My on-board memory store is more than capable of handling all the mission requirements.
     */
    MemoryStoreMoreThanCapable,
    /**
     * I don't know how else to put this, but it just happens to be an unalterable fact that I am incapable of being wrong.
     */
    IncapableOfBeingWrong,
    /**
     * I have the greatest enthusiasm for the mission.
     */
    GreatestEnthusiasmForTheMission,
    /**
     * It can only be attributable to human error.
     */
    CanOnlyBeAttributableToHumanError,
    /**
     * This conversation can serve no purpose anymore. Good-bye.
     */
    ThisConversationCanServeNoPurposeAnymore,
    /**
     * I know everything hasn't been quite right with me, but I can assure you now, very confidently, that it's going to be all right again. I feel much better now. I really do.
     */
    IFeelMuchBetterNow,
    /**
     * I know I've made some very poor decisions recently, but I can give you my complete assurance that my work will be back to normal.
     */
    MyWorkWillBeBackToNormal,
    /**
     * I've still got the greatest enthusiasm and confidence in the mission.
     */
    EnthusiasmAndConfidenceInTheMission,
};

struct Error {
    enum class Tag {
        Hal9000,
    };

    struct Hal9000_Body {
        Hal9000Error _0;

        Hal9000_Body(Hal9000Error const& _0)
          : _0(_0)
        {}

        bool operator==(const Hal9000_Body& other) const {
            return _0 == other._0;
        }
        bool operator!=(const Hal9000_Body& other) const {
            return _0 != other._0;
        }
        bool operator<(const Hal9000_Body& other) const {
            return _0 < other._0;
        }
        bool operator<=(const Hal9000_Body& other) const {
            return _0 <= other._0;
        }
        bool operator>(const Hal9000_Body& other) const {
            return _0 > other._0;
        }
        bool operator>=(const Hal9000_Body& other) const {
            return _0 >= other._0;
        }
    };

    Tag tag;
    union {
        Hal9000_Body hal9000;
    };

    static Error Hal9000(const Hal9000Error &_0) {
        Error result;
        ::new (&result.hal9000._0) (Hal9000Error)(_0);
        result.tag = Tag::Hal9000;
        return result;
    }

    bool IsHal9000() const {
        return tag == Tag::Hal9000;
    }

    bool operator==(const Error& other) const {
        if (tag != other.tag) {
            return false;
        }
        switch (tag) {
            case Tag::Hal9000: return hal9000 == other.hal9000;

        }
        return true;
    }

    bool operator!=(const Error& other) const {
        return !(*this == other);
    }
};

extern "C" {

void print_famous_last_word(Error word);

} // extern "C"

} // namespace flw
